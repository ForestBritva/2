#include <iostream>
#include <vector>
#include <string>
#include <stdexcept>
using namespace std;

// Структура для представления цвета
struct Цвет {
    uint8_t r, g, b, a;

    Цвет() : r(0), g(0), b(0), a(0) {} // Конструктор по умолчанию
    Цвет(uint8_t r, uint8_t g, uint8_t b, uint8_t a = 255) : r(r), g(g), b(b), a(a) {}

    Цвет красный() { 
        Цвет* цв = new Цвет(255, 0, 0); 
        Цвет результат = *цв; 
        delete цв; // Освобождаем память
        return результат; 
    }
    Цвет зелёный() { 
        Цвет* цв = new Цвет(0, 255, 0); 
        Цвет результат = *цв; 
        delete цв; 
        return результат; 
    }
    Цвет синий() { 
        Цвет* цв = new Цвет(0, 0, 255); 
        Цвет результат = *цв; 
        delete цв; 
        return результат; 
    }
    Цвет чёрный() { 
        Цвет* цв = new Цвет(0, 0, 0); 
        Цвет результат = *цв; 
        delete цв; 
        return результат; 
    }
    Цвет белый() { 
        Цвет* цв = new Цвет(255, 255, 255); 
        Цвет результат = *цв; 
        delete цв; 
        return результат; 
    }
};

Цвет* данные_цвета = new Цвет(); // Глобальный объект цвета

// Класс узла
class ПростойУзел {
private:
    int _номер;
    Цвет _цвет;
    double _x_координата, _y_координата;

protected:
    ПростойУзел() {}

public:
    ПростойУзел(int номер) {
        if (номер < 0) {
            throw invalid_argument("Ошибка: номер узла не может быть отрицательным!");
        }
        _номер = номер;
        _x_координата = 0;
        _y_координата = 0;
        _цвет = данные_цвета->белый();
    }

    void Установить_Номер(int номер) {
        if (номер < 0) {
            throw invalid_argument("Ошибка: номер узла не может быть отрицательным!");
        }
        _номер = номер;
    }
    int Получить_Номер() { return _номер; }

    void Установить_Цвет(Цвет цвет) { _цвет = цвет; }
    string Получить_Цвет_строка() {
        return "{ r:" + to_string(_цвет.r) + ", g:" + to_string(_цвет.g) + ", b:" + to_string(_цвет.b) + " }";
    }

    void Установить_X(double x) { _x_координата = x; }
    string Получить_X_строка() { return to_string(_x_координата); }
    int Получить_X() { return _x_координата; }

    void Установить_Y(double y) { _y_координата = y; }
    string Получить_Y_строка() { return to_string(_y_координата); }
};

// Класс ветви
class ПростаяВетвь {
private:
    ПростойУзел* _начало_узел;
    ПростойУзел* _конец_узел;
    Цвет _цвет;

public:
    ПростаяВетвь(ПростойУзел* начало, ПростойУзел* конец, Цвет цвет) {
        if (!начало || !конец) {
            throw invalid_argument("Ошибка: указатель на узел не может быть nullptr!");
        }
        _начало_узел = начало;
        _конец_узел = конец;
        _цвет = цвет;
    }

    void Установить_Узлы(ПростойУзел* начало, ПростойУзел* конец) {
        if (!начало || !конец) {
            throw invalid_argument("Ошибка: указатель на узел не может быть nullptr!");
        }
        _начало_узел = начало;
        _конец_узел = конец;
    }

    void Установить_Цвет(Цвет цвет) { _цвет = цвет; }
    Цвет Получить_Цвет() { return _цвет; }
    string Получить_Цвет_строка() {
        return "r:" + to_string(_цвет.r) + ", g:" + to_string(_цвет.g) + ", b:" + to_string(_цвет.b);
    }

    int Получить_НачальныйНомер() { return _начало_узел->Получить_Номер(); }
    int Получить_КонечныйНомер() { return _конец_узел->Получить_Номер(); }
};

// Класс сети
class ПростаяСеть {
private:
    vector<ПростойУзел*>* _массив_узлов;
    vector<ПростаяВетвь*>* _массив_ветвей;
    int _количество_узлов;
    int _количество_ветвей;

public:
    ПростаяСеть() {
        _количество_узлов = 0;
        _количество_ветвей = 0;
        _массив_узлов = new vector<ПростойУзел*>();
        _массив_ветвей = new vector<ПростаяВетвь*>();
    }

    ~ПростаяСеть() {
        for (auto узел : *_массив_узлов) delete узел;
        for (auto ветвь : *_массив_ветвей) delete ветвь;
        delete _массив_узлов;
        delete _массив_ветвей;
    }

    void ДобавитьУзел(double x, double y, Цвет цвет) {
        ПростойУзел* новый_узел = new ПростойУзел(_количество_узлов);
        новый_узел->Установить_X(x);
        новый_узел->Установить_Y(y);
        новый_узел->Установить_Цвет(цвет);
        _массив_узлов->push_back(новый_узел);
        _количество_узлов++;
    }

    bool ДобавитьВетвь(int номер_начала, int номер_конца, Цвет цвет) {
        ПростойУзел* начало = ПолучитьУзелПоИндексу(номер_начала);
        ПростойУзел* конец = ПолучитьУзелПоИндексу(номер_конца);
        if (начало && конец) {
            ПростаяВетвь* новая_ветвь = new ПростаяВетвь(начало, конец, цвет);
            _массив_ветвей->push_back(новая_ветвь);
            _количество_ветвей++;
            return true;
        }
        return false;
    }

    ПростойУзел* ПолучитьУзелПоИндексу(int индекс) {
        if (индекс < 0 || индекс >= _количество_узлов) {
            return nullptr;
        }
        return _массив_узлов->at(индекс);
    }

    ПростаяВетвь* ПолучитьВетвьПоИндексу(int индекс) {
        if (индекс < 0 || индекс >= _количество_ветвей) {
            return nullptr;
        }
        return _массив_ветвей->at(индекс);
    }

    void ВывестиДанные() {
        for (int i = 0; i < _количество_узлов; i++) {
            ПростойУзел* узел = ПолучитьУзелПоИндексу(i);
            if (!узел) {
                throw runtime_error("Ошибка: узел с индексом " + to_string(i) + " не найден!");
            }
            cout << "\nУзел: номер = " << узел->Получить_Номер()
                 << ", Цвет = " << узел->Получить_Цвет_строка()
                 << ", x = " << узел->Получить_X_строка()
                 << ", y = " << узел->Получить_Y_строка();
        }
        for (int i = 0; i < _количество_ветвей; i++) {
            ПростаяВетвь* ветвь = ПолучитьВетвьПоИндексу(i);
            if (!ветвь) {
                throw runtime_error("Ошибка: ветвь с индексом " + to_string(i) + " не найдена!");
            }
            cout << "\nВетвь: начальный узел = " << ветвь->Получить_НачальныйНомер()
                 << ", конечный узел = " << ветвь->Получить_КонечныйНомер()
                 << ", Цвет = " << ветвь->Получить_Цвет_строка();
        }
    }

    int КоличествоУзлов() { return _количество_узлов; }
    int КоличествоВетвей() { return _количество_ветвей; }

    void Масштабировать_X(double масштаб) {
        if (масштаб <= 0) {
            throw invalid_argument("Ошибка: масштаб должен быть положительным!");
        }
        for (int i = 0; i < _количество_узлов; i++) {
            ПростойУзел* узел = ПолучитьУзелПоИндексу(i);
            int x_новый = (int)(узел->Получить_X() * масштаб);
            узел->Установить_X(x_новый);
        }
    }

    void Установить_Цвет_Ветвей(Цвет цвет) {
        for (int i = 0; i < _количество_ветвей; i++) {
            ПростаяВетвь* ветвь = ПолучитьВетвьПоИндексу(i);
            ветвь->Установить_Цвет(цвет);
        }
    }
};

int main() {
    try {
        cout << "Начало программы\n";
        cout << "Номер билета: 24\n"; // Явное отображение номера билета

        ПростаяСеть* сеть = new ПростаяСеть();

        // Узлы для цифры 2
        сеть->ДобавитьУзел(0, 0, данные_цвета->зелёный());   // 0: верхний левый
        сеть->ДобавитьУзел(10, 0, данные_цвета->зелёный());  // 1: верхний правый
        сеть->ДобавитьУзел(10, 5, данные_цвета->зелёный());  // 2: средний правый
        сеть->ДобавитьУзел(0, 10, данные_цвета->зелёный());  // 3: нижний левый
        сеть->ДобавитьУзел(10, 10, данные_цвета->зелёный()); // 4: нижний правый

        // Ветви для цифры 2 (форма: верхняя линия, диагональ, нижняя линия)
        сеть->ДобавитьВетвь(0, 1, данные_цвета->красный()); // Верхняя горизонталь
        сеть->ДобавитьВетвь(1, 3, данные_цвета->красный()); // Диагональ
        сеть->ДобавитьВетвь(3, 4, данные_цвета->красный()); // Нижняя горизонталь

        // Узлы для цифры 4
        сеть->ДобавитьУзел(20, 0, данные_цвета->зелёный());  // 5: верхний левый
        сеть->ДобавитьУзел(20, 5, данные_цвета->зелёный());  // 6: средний левый
        сеть->ДобавитьУзел(30, 5, данные_цвета->зелёный());  // 7: средний правый
        сеть->ДобавитьУзел(20, 10, данные_цвета->зелёный()); // 8: нижний левый

        // Ветви для цифры 4 (форма: вертикаль и горизонталь)
        сеть->ДобавитьВетвь(5, 8, данные_цвета->красный()); // Вертикаль
        сеть->ДобавитьВетвь(6, 7, данные_цвета->красный()); // Горизонталь

        // Выводим данные графа
        cout << "\nГрафическое представление номера билета 24:\n";
        сеть->ВывестиДанные();

        // Масштабируем координаты X
        сеть->Масштабировать_X(2);
        // Устанавливаем чёрный цвет для ветвей
        сеть->Установить_Цвет_Ветвей(данные_цвета->чёрный());

        // Повторный вывод данных
        cout << "\nПосле масштабирования X и изменения цвета ветвей:\n";
        сеть->ВывестиДанные();

        // Освобождаем память
        delete сеть;
        delete данные_цвета;

    } catch (const invalid_argument& e) {
        cerr << e.what() << endl;
        return 1;
    } catch (const runtime_error& e) {
        cerr << e.what() << endl;
        return 1;
    } catch (...) {
        cerr << "Неизвестная ошибка!" << endl;
        return 1;
    }

    return 0;
}
